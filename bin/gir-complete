#!/bin/sh

#grab colors if available
if [[ -f $HOME/.colors ]] ; then
  source $HOME/.colors
fi
inputstr="$@"

# print the program usage and exit
function printUsage(){
cat - << EOF
$(basename $0) Usage: gir [-c] [-ihl] [-s {directory}]
  EXPLANATION
      $(basename $0) is a program designed to log and maintain several 
      git repositories collectively. This way you can push and pull from
      multiple repos in a row for several unrelated projects. It also makes
      it possible to share/sync multiple repos accross multiple computers 
      quickly. A single log file is created for this: \$LOGS_DIR/gir-git_record.
      
      Make sure that LOGS_DIR is an environment variable set your shell
      startup file before running.

  OPTIONS
      -c         collect [run in a directory that contains one or more git repositories]
      -i         information
      -h         push (pull always performed before push if both selected)
      -l         pull (pull always performed before push if both selected)
      -s         select only a single given directory

  ENVIRONMENT
      LOGS_DIR   A directory that holds log information
EOF

exit $1
}
if [ $# -eq 0 ] ; then
  #if no arguments supplied, print the usage
  printUsage 
fi

# Check to see if LOGS_DIR is set
if [[ ! -n $LOGS_DIR ]] ; then
  echo "$(basename $0): LOGS_DIR is not yet set!" >&2
  printUsage 1
else
  logFile=$LOGS_DIR/gir-git_record
  # check the size of the logfile
  unset NO_LOG
  if [[ $(cat $logFile 2> /dev/null | wc -l) -le 0 ]] ; then
    NO_LOG=1
  fi
fi

function errorNoLogs(){
if [[ -n $NO_LOG ]] ; then
  echo "$(basename $0): No logs yet. Run 'gir -c' in relevant directories first" >&2 
  printUsage 1
fi
}

# initialize the variables
function initialize(){
unset OPT_C
unset OPT_I
unset OPT_H
unset OPT_L
unset OPT_S
}
initialize

# collection function
function collecthere(){
# the top-level directory of the git tree
gitTop=$(git rev-parse --show-toplevel 2> /dev/null)

# find collect the info if available
if [[ "x$gitTop" != "x" ]] ; then
  # this is a git directory!
  grep "$gitTop" $logFile &> /dev/null
  if [[ $? -eq 1 ]] ; then
    gitURL=$(git remote show origin | grep 'Push' | awk '{print $NF}' )
    if [[ "x$gitURL" != "x" ]] ; then
      echo "$(echo $gitURL | awk '{print $1}') $gitTop" >> $logFile
      echo "new > ${BLUE_BRIGHT}$(basename $gitTop)${NC}"
      IS_GIT=1
    else
      echo "unk > ${YELLOW}$(basename $gitTop) (not recorded: no origin)${NC}" 
      IS_GIT=0
    fi
  else
    echo "old > ${GREEN}$(basename $gitTop)${NC}"
    IS_GIT=1
  fi
fi
}
function collect(){
echo $(basename $0): collect
i=0
# first, try the current directory
unset IS_GIT
collecthere
if [[ -n $IS_GIT ]] ; then
  return
fi
for direc in $(ls -la | egrep "^d" | awk '{print $NF}' )
do
  # loops only direcectories
  if [[ ! -L $direc  && $direc != '..' && $direc != '.' ]] ; then
    cd $direc
    unset IS_GIT
    collecthere
    cd ..
    let i++
  fi
done
}

# info function
function infohere(){
url=$1
header=$2
pushd . > /dev/null
ech "  - "
popd > /dev/null
}
# pull function
function pullhere(){
url=$1
header=$2
pushd . > /dev/null
if [[ -d $header ]] ; then
  echo "<--- pulling ... "
  cd $header
  { 
    git pull && echo "${GREEN}pulled${NC}" 
  } || {
    echo "${ERROR_RED}*** not pulled ($header)$NC"
  }
else
  echo "<--- cloning ..."
  { 
    git clone $url $header && echo "${BLUE_BRIGHT}cloned${NC}"  
  } || {
    echo "${ERROR_RED}*** not cloned ($header)$NC"
  }
fi
  popd > /dev/null
}
# push function
function pushhere(){
url=$1
header=$2
pushd . > /dev/null
  if [[ -d $header ]] ; then
    echo "---> pushing ... "
    cd $header
    { 
      git push && echo  "${GREEN}pushed${NC}" 
    } || {
      echo  "${ERROR_RED}*** not pushed ($header)$NC"
    }
  else
    echo  "${ERROR_RED}*** no directory ($header)$NC"
  fi
  popd > /dev/null
}

# find absolute path of given input
function abspath(){
pushd . > /dev/null; 
if [ -d "$1" ]; then 
   cd "$1"; 
   dirs -l +0; 
else 
   cd "`dirname \"$1\"`"; 
   cur_dir=`dirs -l +0`; 
   if [ "$cur_dir" == "/" ]; then 
      echo "$cur_dir`basename \"$1\"`"; 
   else 
      echo "$cur_dir/`basename \"$1\"`"; 
   fi; 
fi; 
popd > /dev/null; 
}
# check the selected directory
function checkSOpt(){
  if [[ "x$(grep $OPT_S $logFile)" != "x" && -d $OPT_S ]] ; then
    S_URL=$(grep "$OPT_S" $logFile | awk '{print $1}')
    S_DIR=$OPT_S
  else
    echo "$(basename $0): Not valid git-recording $OPT_S" >&2 
    printUsage 1
  fi
  if [[ $(echo $S_URL | wc -w) -gt 1 ]] ; then
    echo "$(basename $0): Do not run selection from parent directories" >&2
    printUsage 1
  fi
}

# parse the given options
while getopts ":cihls:" opt; do
  case $opt in
    c)
      OPT_C=1
      collect
      exit 
      ;;
    i)
      errorNoLogs
      OPT_I=1
     ;;
    h)
      errorNoLogs
      OPT_H=1
      ;;
    l)
      errorNoLogs
      OPT_L=1
      ;;
    s)
      errorNoLogs
      OPT_S=$(abspath $OPTARG)
      checkSOpt
      ;;
    \?)
      echo "$(basename $0): Invalid option: -$OPTARG" >&2
      printUsage 1
      ;;
    :)
      echo "$(basename $0): Option -$OPTARG requires an argument." >&2
      printUsage 1
      ;;
  esac
done

# perform the necessary functions 
pushd . > /dev/null
echo "$(basename $0): $inputstr"
i=0
while read line ; do
  echo "-----------"

  if [[ ! -n $OPT_S ]] ; then
    url=$(echo $line | awk '{print $1}')
    direc=$(echo $line | awk '{print $2}')
  else
    url=$S_URL
    direc=$S_DIR
  fi

  header=$(basename $direc)
  parent=${direc%/*}

  # make sure that the parent directory exists
  mkdir -p $parent
  cd $parent

  echo "${header}: "
  # informative output
  if [[ -n $OPT_I ]] ; then
    infohere $url $header
  fi
  # pulling
  if [[ -n $OPT_L ]] ; then
    pullhere $url $header
  fi
  #pushing
  if [[ -n $OPT_H ]] ; then
    pushhere $url $header
  fi
  
  # we have already done the one directory; so leave!
  if [[ -n $OPT_S ]] ; then
    break
  fi
  let i++
done < $logFile
popd > /dev/null
