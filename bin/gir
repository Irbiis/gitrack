#!/bin/sh

#grab colors if available
if [[ -f $HOME/.colors ]] ; then
  source $HOME/.colors
fi
inputstr="$@"

# print the program usage and exit
function printUsage(){
cat - << EOF
$(basename $0) Usage: gir [-c] [-ihl] [-s {directory}]
  EXPLANATION
      $(basename $0) is a program designed to log and maintain several 
      git repositories collectively. This way you can push and pull from
      multiple repos in a row for several unrelated projects. It also makes
      it possible to share/sync multiple repos accross multiple computers 
      quickly. A single log file is created for this: \$LOGS_DIR/gir-git_record.
      
      Make sure that LOGS_DIR is an environment variable set your shell
      startup file before running.

  OPTIONS
      -c         collect [run in a directory that contains one or more git repositories]
      -i         information
      -h         push (pull always performed before push if both selected)
      -l         pull (pull always performed before push if both selected)
      -n         negate the -q option
      -q         quiet mode (only prints if action were performed. Also, implied '-i')
      -s         select only a single given directory

  ENVIRONMENT
      LOGS_DIR   A directory that holds log information
EOF

exit $1
}
if [ $# -eq 0 ] ; then
  #if no arguments supplied, print the usage
  printUsage 
fi

# Check to see if LOGS_DIR is set
if [[ ! -n $LOGS_DIR ]] ; then
  echo "$(basename $0): LOGS_DIR is not yet set!" >&2
  printUsage 1
else
  logFile=$LOGS_DIR/gir-git_record
  # check the size of the logfile
  unset NO_LOG
  if [[ $(cat $logFile 2> /dev/null | wc -l) -le 0 ]] ; then
    NO_LOG=1
  fi
fi

function errorNoLogs(){
if [[ -n $NO_LOG ]] ; then
  echo "$(basename $0): No logs yet. Run 'gir -c' in relevant directories first" >&2 
  printUsage 1
fi
}

# initialize the variables
function initialize(){
unset OPT_C
unset OPT_I
unset OPT_H
unset OPT_L
unset OPT_Q
unset OPT_S
}
initialize

# collection function
function collecthere(){
# the top-level directory of the git tree
gitTop=$(git rev-parse --show-toplevel 2> /dev/null)

# find collect the info if available
if [[ "x$gitTop" != "x" ]] ; then
  # this is a git directory!
  grep "$gitTop" $logFile &> /dev/null
  if [[ $? -eq 1 ]] ; then
    gitURL=$(git remote show origin | grep 'Push' | awk '{print $NF}' )
    if [[ "x$gitURL" != "x" ]] ; then
      echo "$(echo $gitURL | awk '{print $1}') $gitTop" >> $logFile
      echo "new > ${BLUE_BRIGHT}$(basename $gitTop)${NC}"
      IS_GIT=1
    else
      echo "unk > ${YELLOW}$(basename $gitTop) (not recorded: no origin)${NC}" 
      IS_GIT=0
    fi
  else
    echo "old > ${GREEN}$(basename $gitTop)${NC}"
    IS_GIT=1
  fi
fi
}
function collect(){
echo $(basename $0): collect
i=0
# first, try the current directory
unset IS_GIT
collecthere
if [[ -n $IS_GIT ]] ; then
  return
fi
for direc in $(ls -la | egrep "^d" | awk '{print $NF}' )
do
  # loops only direcectories
  if [[ ! -L $direc  && $direc != '..' && $direc != '.' ]] ; then
    cd $direc
    unset IS_GIT
    collecthere
    cd ..
    let i++
  fi
done
}

# info function
function infohere(){
url=$1
header=$2
pushd . > /dev/null
cd $header
branch=$(basename $(git symbolic-ref HEAD))

# TODO: add remote/commit information to this printout

# stats
modified=$(git ls-files --modified | wc -l)
others=$(git ls-files --others --exclude-standard | wc -l)
staged=$(git diff --staged --name-status | wc -l)
totalcount=$(($modified + $others + $staged ))

# setup color
unset stagColor
if [[ $staged -gt 0 ]] ; then
  stagColor=$GREEN
fi

unset modColor
if [[ $modified -gt 0 ]] ; then
  modColor=$RED
fi

unset otherColor
if [[ $others -gt 0 ]] ; then
  otherColor=$ERROR_RED
fi

# print out the information
echo "  - branch: $branch"
echo "  ${stagColor}${modColor}${otherColor}- status:${NC}"
echo "    * ${stagColor}staged:   $staged${NC}"
echo "    * ${modColor}modified: $modified${NC}"
echo "    * ${otherColor}others:   $others${NC}"
popd > /dev/null
}
# pull function
function pullhere(){
url=$1
header=$2
pushd . > /dev/null
if [[ -d $header ]] ; then
  echo "<--- pulling ... "
  cd $header
  { 
    git pull && echo "${GREEN}pulled${NC}" 
  } || {
    echo "${ERROR_RED}*** not pulled ($header)$NC"
  }
else
  echo "<--- cloning ..."
  { 
    git clone $url $header && echo "${BLUE_BRIGHT}cloned${NC}"  
  } || {
    echo "${ERROR_RED}*** not cloned ($header)$NC"
  }
fi
  popd > /dev/null
}
# push function
function pushhere(){
url=$1
header=$2
pushd . > /dev/null
  if [[ -d $header ]] ; then
    echo "---> pushing ... "
    cd $header
    { 
      git push && echo  "${GREEN}pushed${NC}" 
    } || {
      echo  "${ERROR_RED}*** not pushed ($header)$NC"
    }
  else
    echo  "${ERROR_RED}*** no directory ($header)$NC"
  fi
  popd > /dev/null
}

# find absolute path of given input
function abspath(){
pushd . > /dev/null; 
if [ -d "$1" ]; then 
   cd "$1"; 
   dirs -l +0; 
else 
   cd "`dirname \"$1\"`"; 
   cur_dir=`dirs -l +0`; 
   if [ "$cur_dir" == "/" ]; then 
      echo "$cur_dir`basename \"$1\"`"; 
   else 
      echo "$cur_dir/`basename \"$1\"`"; 
   fi; 
fi; 
popd > /dev/null; 
}
# check the selected directory
function checkSOpt(){
  if [[ "x$(grep $OPT_S $logFile)" != "x" && -d $OPT_S ]] ; then
    S_URL=$(grep "$OPT_S" $logFile | awk '{print $1}')
    S_DIR=$OPT_S
  else
    echo "$(basename $0): Not valid git-recording $OPT_S" >&2 
    printUsage 1
  fi
  if [[ $(echo $S_URL | wc -w) -gt 1 ]] ; then
    echo "$(basename $0): Do not run selection from parent directories" >&2
    printUsage 1
  fi
}

# total running checks
function runGitRecorderHere(){
  echo "================="
  echo "${header}: "
  # informative output
  if [[ -n $OPT_I ]] ; then
    infohere $url $header
  fi
  # pulling
  if [[ -n $OPT_L ]] ; then
    pullhere $url $header
  fi
  #pushing
  if [[ -n $OPT_H ]] ; then
    pushhere $url $header
  fi
}
# check if the return was "up-to-date"
function upToDate(){
if [[ -n $OPT_H && -n $OPT_L ]] ; then
  expected=2
elif [[ ! -n $OPT_H && ! -n $OPT_L ]] ; then
  expected=0
else
  expected=1
fi
tmpFile=$1
lines=$(grep "up-to-date" $tmpFile 2> /dev/null | wc -l)
if [[ $lines -eq $expected ]] ; then
  unset NotUpToDate
else
  NotUpToDate=1
fi
}

# parse the given options
while getopts ":cihlqs:" opt; do
  case $opt in
    c)
      OPT_C=1
      collect
      exit 
      ;;
    i)
      errorNoLogs
      OPT_I=1
     ;;
    h)
      errorNoLogs
      OPT_H=1
      ;;
    l)
      errorNoLogs
      OPT_L=1
      ;;
    n)
      unset OPT_Q
      ;;
    q)
      OPT_I=1
      OPT_Q=1
      ;;
    s)
      errorNoLogs
      OPT_S=$(abspath $OPTARG)
      checkSOpt
      ;;
    \?)
      echo "$(basename $0): Invalid option: -$OPTARG" >&2
      printUsage 1
      ;;
    :)
      echo "$(basename $0): Option -$OPTARG requires an argument." >&2
      printUsage 1
      ;;
  esac
done

# perform the necessary functions 
pushd . > /dev/null
if [[ ! -n $OPT_Q ]] ; then 
  echo "$(basename $0): $inputstr"
fi
i=0
while read line ; do

  if [[ ! -n $OPT_S ]] ; then
    url=$(echo $line | awk '{print $1}')
    direc=$(echo $line | awk '{print $2}')
  else
    url=$S_URL
    direc=$S_DIR
  fi

  header=$(basename $direc)
  parent=${direc%/*}

  # make sure that the parent directory exists
  mkdir -p $parent
  cd $parent

  # run the recorder
  if [[ -n $OPT_Q ]] ; then
    tmp=$(mktemp -t $(basename $0).XXXX)

    # gotta check info, if silent mode
    infohere $url $header > $tmp

    # TODO: checking upstream could negate the need for this if totalcount were 0
    # now run the desired functions
    runGitRecorderHere &> $tmp

    # check if the given directory was already up to date
    upToDate $tmp

    if [[ $totalcount -gt 0 || -n $NotUpToDate  ]] ; then
      # if the test came up positive, print to screen
      cat $tmp 
    fi
    rm $tmp &> /dev/null
  else
    runGitRecorderHere 
  fi

  # we have already done the one directory; so leave!
  if [[ -n $OPT_S ]] ; then
    break
  fi
  let i++
done < $logFile
popd > /dev/null
